---
title: "C++ 与 右值引用"
date: 2020-12-12T22:22:28+08:00
draft: false
---

C++11 添加了右值引用的特性，不仅让我们能够使用`移动语义`，而且
还可以通过`完美转发`编写接收任意实参的模板

<!--more-->

## 左值与右值

在 C++ 中，一切值都分为[左值]^(lvalue)和[右值]^(rvalue)

在 C 语言中，我们把等号左边的称为左值，等号右边的称为右值

```c
int a = 0; // 这里0是右值,a是左值
int b = a;// 这里a是右值,b是左值
```

{{< admonition note "C++11 中的左值与右值" >}}
在 C++11 中，左值和右值的概念被重新解释

1. [L-Value]^(左值)中的 L 被重新解释成 `Location`，即左值代表具有内存地址的一类表达式
2. [R-Value]^(右值)中的 R 被重新解释成 `Read`，即右值代表具有只读的一类表达式

{{< /admonition >}}

## 右值引用

在C++98中，所有的引用都是左值引用，我们只能对左值取引用

```cpp
int a = 0;
int& p1 = a; // 合法
int& p2 = 0; // 非法操作，左值引用无法指向右值
const int& p3 = 0; // 合法，const引用可以指向右值
```

在C++11中，提供了**右值引用**的支持

```cpp
int a = 0;
int&& p1 = 0; // 合法，右值引用指向右值
int&& p2 = a; // 非法，右值引用指向左值 
```

标准库中的`std::move`可以将左值强制转换为右值，例如

```cpp
int a = 5;
int&& b = std::move(a); // 将左值转换为右值
std::cout << a; // 输出为 5
```

`std::move`这个名字非常右迷惑性，虽然名字是move，但它并没有将一个变量中的值
移入到另一个变量当中，本质上执行的是`static_cast<T&&>(lvalue)`操作。

## 移动语义

在 C/C++ 中，构造，返回，传参等等默认采用都的是[拷贝]^(copy)的语义

```cpp
int a,b;
a = 5;
b = a;
```

例如在这份代码中，对`b`赋值采用的方式是将先拷贝变量`a`，再将拷贝的临时变量赋值给`b`，
在变量结构复杂的情况下，复制操作的代价是非常高的，C语言中我们可以使用指针来处理这个问题，
但指针是非常危险的。

于是在 C++ 中，我们C++中可以使用引用，它的机制和指针类似，但是比指针更加安全，引用的
使用让我们可以在传参时使用得安全，快速方式，但并没解决返回和构造的拷贝问题。

在 C++ 11 中右值引用的出现，使得我们可以用[移动]^(move)语义解决C++中的拷贝问题
(咕咕咕。。。)
