<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - wdvxdr's blog</title><link>https://www.wdvxdr.com/posts/</link><description>所有文章 | wdvxdr's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>wdvxdr1123@gmail.com (wdvxdr)</managingEditor><webMaster>wdvxdr1123@gmail.com (wdvxdr)</webMaster><lastBuildDate>Wed, 11 Aug 2021 23:16:16 +0800</lastBuildDate><atom:link href="https://www.wdvxdr.com/posts/" rel="self" type="application/rss+xml"/><item><title>突破限制，在 Go 中调用非导出方法</title><link>https://www.wdvxdr.com/posts/8.11.invoke_non_export_method_in_go/</link><pubDate>Wed, 11 Aug 2021 23:16:16 +0800</pubDate><author><name>wdvxdr</name></author><guid>https://www.wdvxdr.com/posts/8.11.invoke_non_export_method_in_go/</guid><description>调用非导出函数在 go 语言中，所有的导出与非导出都由标志符的第一个字母是否大写决定。 有时候，我们可能需要调用一个私有方法或私有函数。对于函数，我</description></item><item><title>在Go1.16导出C文件中的函数</title><link>https://www.wdvxdr.com/posts/go1.16-cgo-export/</link><pubDate>Fri, 02 Apr 2021 15:23:02 +0800</pubDate><author><name>wdvxdr</name></author><guid>https://www.wdvxdr.com/posts/go1.16-cgo-export/</guid><description>缘起在群里聊天时，听到了群友说在更新了Go 1.16后，使用c-shared编译无法导出C文件中 定义的导出函数。处于兴趣，我便开始探索无法导出</description></item><item><title>Golang Mutex源码分析</title><link>https://www.wdvxdr.com/posts/go_mutex/</link><pubDate>Mon, 14 Dec 2020 14:27:08 +0800</pubDate><author><name>wdvxdr</name></author><guid>https://www.wdvxdr.com/posts/go_mutex/</guid><description><![CDATA[<p>Golang标准库中提供了<strong><ruby>互斥锁<rt>Mutex</rt></ruby></strong>的原语来解决并发资源竞争，这篇文章探讨了标准库
中Mutex的实现原理</p>]]></description></item><item><title>基环树DP</title><link>https://www.wdvxdr.com/posts/ji-huan-shu-dp/</link><pubDate>Mon, 25 Dec 2017 19:18:23 +0800</pubDate><author><name>wdvxdr</name></author><guid>https://www.wdvxdr.com/posts/ji-huan-shu-dp/</guid><description>note 从博客园迁移，复习一下以前学的内容 一般的树形DP都是在树上进行，即有N个点和N-1条边。可是有一类问题是N个点和N条边，这样一定会有环，这</description></item></channel></rss>