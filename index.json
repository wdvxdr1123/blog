[{"categories":null,"content":"缘起 在群里聊天时，听到了群友说在更新了Go 1.16后，使用c-shared编译无法导出C文件中 定义的导出函数。处于兴趣，我便开始探索无法导出的缘由。 ","date":"2021-04-02","objectID":"/posts/go1.16-cgo-export/:1:0","tags":null,"title":"在Go1.16导出C文件中的函数","uri":"/posts/go1.16-cgo-export/"},{"categories":null,"content":"排查过程 package main import \"C\" //export AddGo func AddGo(a C.int,b C.int) C.int { return C.int(int(a) + int(b)) } func main() {} extern int __stdcall AddC(int a,int b) { return a + b; } 将这两文件放一个文件夹，使用 go build -buildmode=c-shared -o a.dll 进行编译， 然后使用dumpbin工具查看导出函数 Go 1.16 ordinal hint RVA name 1 0 0006F640 AddGo 2 1 00138410 _cgo_dummy_export 发现确实只导出了Go文件中使用 //export 导出的函数。 ","date":"2021-04-02","objectID":"/posts/go1.16-cgo-export/:2:0","tags":null,"title":"在Go1.16导出C文件中的函数","uri":"/posts/go1.16-cgo-export/"},{"categories":null,"content":"Go 1.16 在CGO中的改动 在go仓库中搜寻有无类似 issue 时，go1.16 修复的一个 bug 引起了我的注意 #43591 其大致内容是，使用 c-shared 编译时，会导出很多很多函数，不仅仅是标注为 //export 的函数，很多标准库中的函数，包括运行时内部的 函数也被导出。 我查看了修复这个 bug 的 commit 记录link. 修复的 commit 记录\" 修复的 commit 记录 从这条 commit 中可以看出， cgo 工具在go 1.16中为所有Go文件中定义的导出函数加上了 __declspec(dllexport)， 这样没有使用 //export 的函数就不会被导出，但是我们的 C 文件中定义的函数也会被忽略。 由此，我们很容易得出解决方法——将c函数加上__declspec(dllexport)。 extern int __stdcall __declspec(dllexport) AddC(int a,int b) { return a + b; } 重新编译后，使用 dumpbin 查看导出函数 ordinal hint RVA name 1 0 0006F6A0 AddC 2 1 0006F640 AddGo 3 2 00138410 _cgo_dummy_export 不出所料，AddC 函数成功的被导出。问题成功解决!!! ","date":"2021-04-02","objectID":"/posts/go1.16-cgo-export/:3:0","tags":null,"title":"在Go1.16导出C文件中的函数","uri":"/posts/go1.16-cgo-export/"},{"categories":null,"content":"前言 在开源项目 go-cqhttp 中，我提交了两个 pr(#659,#660) 使得CQ码 (一种用字符串表示IM消息的方式)效率变为了原来的400%。 这篇文章简单介绍了加速解析的原理，里面的某些优化方法对 Go 语言是通用的， 希望能对读者优化 Go 程序有一定启发。 ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:1:0","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"CQ码解析的原方案 ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:2:0","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"CQ码的语法规则 CQ码的表示可以为[1] CQCode:\"[CQ:\"Type(','ParameterList)?']';Type:string;ParameterList:Parmeter(','Parmeter)*;Parameter:string'='string;其中Type是消息类型，ParameterList是参数列表 ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:2:1","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"正则表达式解析 在最初解析方案是采用正则表达式，使用标准库中的regex包进行解析 var matchReg = regexp.MustCompile(`\\[CQ:\\w+?.*?]`) var typeReg = regexp.MustCompile(`\\[CQ:(\\w+)`) var paramReg = regexp.MustCompile(`,([\\w\\-.]+?)=([^,\\]]+)`) ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:2:2","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"自动机解析 使用正则表达式可以获得比较高的通用性，可读性，可维护性，但是为了压榨性能，手写自动机就是优化解析的重要途经。 Mrs4s大佬给出了一份自动机解析的实现[2] ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:2:3","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"优化加速 在上一版自动机中，效率比正则表达式提高了 30% ，但这对于性能压榨还不够彻底，于是我便开始了优化之路。 优化后的初稿如下 func ParseCQCode(s string) Message { var d = map[string]string{} // parameters var key, Type = \"\", \"\" l := len(s) i, j := 0, 0 S1: // Plain Text for ; i \u003c l; i++ { if s[i] == '[' \u0026\u0026 s[i:i+4] == \"[CQ:\" { if i \u003e j { saveText(s[j:i]) } i += 4 j = i goto S2 } } goto End S2: // CQCode Type d = map[string]string{} for ; i \u003c l; i++ { switch s[i] { case ',': // CQ Code with params Type = s[j:i] i++ j = i goto S3 case ']': // CQ Code without params Type = s[j:i] i++ j = i saveCQCode() goto S1 } } goto End S3: // CQCode param key for ; i \u003c l; i++ { if s[i] == '=' { key = s[j:i] i++ j = i goto S4 } } goto End S4: // CQCode param value for ; i \u003c l; i++ { switch s[i] { case ',': // more param d[key] = CQCodeUnescapeValue(s[j:i]) i++ j = i goto S3 case ']': d[key] = CQCodeUnescapeValue(s[j:i]) i++ j = i saveCQCode() goto S1 } } goto End End: if i \u003e j { saveText(s[j:i]) } } ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:3:0","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"去除不必要的转换 在上一版自动机中，将整个字符串转换成了 []rune ，观察到 CQ 码的结构中只含有 ASCII 字符，根据 UTF-8 的性质， 所有的非 ASCII 字符的个个字节都大于128，所以对于解析CQ码，我们并不需要将字符串转换成 []rune 。 ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:3:1","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"设计一个更全面的状态机 在上一版状态机中,状态数目较少，只能解析出整个CQ码的字符串，将Type和参数取出来，需要使用Split分割， 于是我设计了一个更加全面的状态机。 相比之前的状态机，可以更加精细的解析CQ码的内容，避免了重复操作，通过一次遍历就完成了所有 CQ码的解析。 ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:3:2","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"避免拷贝，使用切片进行内存复用 对于CQ码，我们只需要从字符串中提取一部分，而且后续的操作中，我们不会对字符串进行修改，所以我是用了切片操作来 截取字符串，尽可能的减少内存分配 ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:3:3","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"消除边界检查 Go语言是一门内存安全的语言，程序运行过程中会进行边界检查，这对程序的稳定避免发生更严重的错误很重要，但是有些情况下， 我们可以保证一定不会发生数组(切片)越界，这时边界检查就变得多余了。 在 Go 编译器中，实现了对某些情况的边界检查消除，例如标准库encoding/binary中 func (littleEndian) PutUint32(b []byte, v uint32) { _ = b[3] // early bounds check to guarantee safety of writes below b[0] = byte(v) b[1] = byte(v \u003e\u003e 8) b[2] = byte(v \u003e\u003e 16) b[3] = byte(v \u003e\u003e 24) } 在第二行中，提前检查了边界，Go编译器就会对后续的4行操作不进行边界检查。 Go对边界检查消除优化还不够全面，往往需要我们手动提示编译器进行边界检查消除。 例如下面代码中，对is的范围进行暗示 func foo(is []int, bs []byte) { if len(is) \u003e= 256 { is = is[:256] // 给编译器一个暗示 for _, n := range bs { _ = is[n] // 边界检查消除了！ } } } 虽然我重写了一遍状态机， 为了探究性能并无很大提升的原因，我使用了 go build -gcflags=\"-d=ssa/check_bce/debug=1\" 查找了代码中所有的边界检查，结果发现代码中几乎所有切片操作都进行了边界检查， 同时，在我的自动机实现代码中，保证了索引一定不会越界 (i \u003c l)，于是我尝试给编译器一定 提示，尝试消除边界检查。 不幸的是，我尝试了已知的所有 Hint 手段，编译器始终不能进行边界检查消除，这时候我选择 另一条道路—— unsafe。 通过 unsafe 操作，实现边界消除。 unsafe unsafe (×) I say it is safe (√) 使用了unsafe操作后的代码如下 // add 指针运算 add := func(ptr unsafe.Pointer, offset uintptr) unsafe.Pointer { return unsafe.Pointer(uintptr(ptr) + offset) } S1: // Plain Text for ; i \u003c l; i++ { if *(*byte)(add(ptr, uintptr(i))) == '[' \u0026\u0026 i+4 \u003c l \u0026\u0026 *(*uint32)(add(ptr, uintptr(i))) == magicCQ { // Magic :uint32([]byte(\"[CQ:\")) if i \u003e j { saveText(s[j:i]) } i += 4 j = i goto S2 } } goto End S2: // CQCode Type d = map[string]string{} for ; i \u003c l; i++ { switch *(*byte)(add(ptr, uintptr(i))) { case ',': // CQ Code with params Type = s[j:i] i++ j = i goto S3 case ']': // CQ Code without params Type = s[j:i] i++ j = i saveCQCode() goto S1 } } goto End S3: // CQCode param key for ; i \u003c l; i++ { if *(*byte)(add(ptr, uintptr(i))) == '=' { key = s[j:i] i++ j = i goto S4 } } goto End S4: // CQCode param value for ; i \u003c l; i++ { switch *(*byte)(add(ptr, uintptr(i))) { case ',': // more param d[key] = CQCodeUnescapeValue(s[j:i]) i++ j = i goto S3 case ']': d[key] = CQCodeUnescapeValue(s[j:i]) i++ j = i saveCQCode() goto S1 } } goto End End: if i \u003e j { saveText(s[j:i]) } return 同时，我将判断是否是CQ码头 \"[CQ:\" 改成了用 uint32 进行比较(与大小端有关),进一步优化了性能. 最终的结果是十分的 Amazing 啊，比重写前的状态机快了几倍。 ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:3:4","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"减少map的创建 目前的实现已经十分快了，正当我觉得没有任何可以优化的地方时，我突然发现了用于保存CQ码参数的map可以进行内存复用。 Go 编译器对map的清空进行了优化，下面这样的代码，Go 编译器会将它优化成一个runtime内部函数，对整个map一次清空。 var a map[type1]type2 for k := range a { delete(a, k) } 虽然并不能释放已使用的内存，但是我们可以复用内存，减少map的扩容，减少alloc，大大提高运行速度。 内存复用 在并发的场景下，可以使用 sync 包中的 sync.Pool 实现线程安全的内存复用。 于是我做了一个小改动 S2: // CQCode Type // d = map[string]string{} // old for k := range a { delete(a, k) } for ; i \u003c l; i++ { // ignore } goto End 经过这次改动后，CQ码的解析速度又提高了33%。 ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:3:5","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"总结 最后总结下来，优化Go程序的性能可以从下面几个角度入手 善于内存复用，使用切片或 sync.Pool 减少内存分配。 尽量避免不必要的类型转换带来的开销，例如 []byte 与 string 之间转换， []rune 与 string 之间的转换。 合理暗示编译器，避免不必要的越界检查。 ","date":"2021-03-22","objectID":"/posts/cqcode_speedup/:4:0","tags":null,"title":"加速CQ码解析背后原理","uri":"/posts/cqcode_speedup/"},{"categories":null,"content":"Golang标准库中提供了互斥锁Mutex的原语来解决并发资源竞争，这篇文章探讨了标准库 中Mutex的实现原理 ","date":"2020-12-14","objectID":"/posts/go_mutex/:0:0","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"基础知识 ","date":"2020-12-14","objectID":"/posts/go_mutex/:1:0","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"信号量 信号量Semaphore 是计算机科学家 Dijkstra 发明的数据结构，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。其本质是一个整数，有两个基本操作： 申请acquire（也称为 wait、decrement 或 P 操作）: 将信号量减 1，如果结果值为负则挂起协程，直到其他线程进行了信号量累加为正数才能恢复。如结果为正数，则继续执行。 释放release（也称 signal、increment 或 V 操作）: 将信号量加 1，如存在被挂起的协程，此时唤醒他们中的一个协程。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:1:1","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"CAS 操作 CAS操作是CPU指令提供的一个原子操作， 其全程为 Compare And Swap，在Go标准库 sync/atomic 中实现了这个方法： // CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value. func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) 这个函数会首先比较指针addr指向的值是否和old是否相等，如果相等则将addr指向的值替换为new，并返回true， 否则不做任何操作，并返回false。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:1:2","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Mutex的第一次提交 在2008年 Russ Cox 提交了第一版的Mutex实现[1]， 当时的实现比较简单，我们先从这一版开始了解Mutex的底层原理，由于当时Go还未发布1.0版本，也没有sync/atomic包，与现在的实现有很大的区别，但这并不影响我们理解其中的逻辑 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:0","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Mutex的定义 export type Mutex struct { key int32; // 记录当前锁是否被某个goroutine持有 sema int32; // 信号量 } 初版的Mutex定义非常简单，使用key记录当前锁是否被持有，sema记录当前信号量 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:1","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"请求锁的实现 func (m *Mutex) Lock() { if xadd(\u0026m.key, 1) == 1 { // 将标记加1，判断是否有其他goroutine持有锁 // changed from 0 to 1; we hold lock return; // 当前 goroutine 持有锁，直接返回 } sys.semacquire(\u0026m.sema); // 挂起当前goroutine，等待调度 } 这个函数实现的很简单，在加锁时，首先将当前锁标记为已持有，如果当前锁没有被其他goroutine持有，则直接返回， 否则，挂起当前goroutine，等待信号量调度。 xadd函数 func xadd(val *int32, delta int32) (new int32) { for { // 不断自旋操作 v := *val; if cas(val, v, v+delta) { // 判断是否被其他goroutine修改 return v+delta; // 返回新值 } } panic(\"unreached\") } xadd通过自旋CAS操作，将val的值加delta，就相当于现在Go语言的atomic.AddInt32 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:2","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"释放锁的实现 释放锁的实现也很简洁: func (m *Mutex) Unlock() { if xadd(\u0026m.key, -1) == 0 { // 将标记减1 // changed from 1 to 0; no contention return; // 如果没有其他goroutine持有锁，直接返回 } sys.semrelease(\u0026m.sema); // 通过信号量唤醒被挂起的goroutine } 释放锁时，首先将当前标记减一，如果当前锁没有被其他goroutine持有，则直接返回， 否则，通过信号量通知运行时，调度被挂起的goroutine。 在这个版本，Mutex已经实现了基本的功能，但是这个版本有一个问题，所有goroutine会排队等待 运行时的调度，虽然这保证了公平性，所有的goroutine都会有机会参与调度，但是从性能的角度上看， 这会导致频繁的上下文切换，如果我们把锁直接交给新人(未挂起的goroutine)，这样就可以避免上下文的切换， 于是Go 团队再 Go1.0 正式版时对Mutex进行了较大的调整。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:3","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"加入唤醒机制 在Go 1.0版本[2]中， Mutex的结构体字段进行了调整 type Mutex struct { state int32 // 复合数据，下文进行解释 sema uint32 // 信号量 } const ( mutexLocked = 1 \u003c\u003c iota // state的第一位，代表当前锁是否被持有 mutexWoken // state的第二位，唤醒标记 mutexWaiterShift = iota // 位移 ) 在这一版中，将Mutex的第一个字段由key改为state，其含义发生了很大的变化，state的第一位表示当前锁是否被持有， 相当于之前的key，state的第二位是唤醒标记，代表当前是否有唤醒的goroutine正在请求锁，剩下的30位用来表示等待中 的Waiter数量。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:0","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Go1.0 请求锁 在这一版中，代码相比第一版有很大变化，其主要优化是给新来的goroutine一些机会，让新goroutine能不参与休眠就获取锁 func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { return // 当前锁未被持有 } awoke := false for { old := m.state new := old | mutexLocked // 新状态加上锁 if old\u0026mutexLocked != 0 { new = old + 1\u003c\u003cmutexWaiterShift // 如果已经有goroutine持有锁，则等待的 Waiter + 1 } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. new \u0026^= mutexWoken // 清空唤醒标记 } if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { // 置新状态 if old\u0026mutexLocked == 0 { break // 旧状态锁已释放，获取当前锁 } runtime_Semacquire(\u0026m.sema) // 请求信号量 awoke = true } } } 我们可以用下面这个状态图表示请求锁的过程 我们可以发现，在这版的Mutex中，给新来的goroutine会在加入等待队列前就去尝试获取锁， 如果失败则加入等待队列中 ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:1","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Go1.0 释放锁 同时在Go 1.0中，释放锁的代码也变得更加复杂了 func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026m.state, -mutexLocked) // 去掉持有锁标记 if (new+mutexLocked)\u0026mutexLocked == 0 { panic(\"sync: unlock of unlocked mutex\") // 重复Unlock时panic } old := new for { // 如果没有其他的waiter // 或者已经有唤醒的goroutine if old\u003e\u003emutexWaiterShift == 0 || old\u0026(mutexLocked|mutexWoken) != 0 { return } // 挑选一个waiter唤醒 new = (old - 1\u003c\u003cmutexWaiterShift) | mutexWoken // 打上唤醒标记 if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { // 置新状态 runtime_Semrelease(\u0026m.sema) return } old = m.state } } 在释放锁时，首先会将锁标记为未锁状态，如果当前锁已经是未锁状态，则会panic(第5行) 如果当前已经有唤醒的goroutine或者没有等待中的waiter，我们就什么都不用做，其他goroutine会自己抢夺这把锁 如果没有唤醒的goroutine,就从等待队列中唤醒一个goroutine ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:2","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"给新 Goroutine 更多机会 在 Go1.5 版本中，Go团队又对Mutex进行了一次优化[3] 在某些临界区，代码执行的速度很快，如果加入等待队列就会浪费很多时间，Go 团队针对这一情景对Mutex进行了优化 func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { if raceenabled { // race detector 相关 raceAcquire(unsafe.Pointer(m)) } return } awoke := false iter := 0 // 自旋次数 for { old := m.state new := old | mutexLocked if old\u0026mutexLocked != 0 { // 当前锁被持有 if runtime_canSpin(iter) { // 检测是否可以自旋 // 如果当前的没有其他唤醒的goroutine // 尝试将当前goroutine置为唤醒状态 // 提醒 Unlock 不去唤醒其他goroutine if !awoke \u0026\u0026 old\u0026mutexWoken == 0 \u0026\u0026 old\u003e\u003emutexWaiterShift != 0 \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) { awoke = true // 设置当前唤醒状态 } runtime_doSpin() iter++ continue // 自旋再次请求锁 } new = old + 1\u003c\u003cmutexWaiterShift // 加入等待队列 } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. if new\u0026mutexWoken == 0 { panic(\"sync: inconsistent mutex state\") } new \u0026^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { if old\u0026mutexLocked == 0 { break } runtime_Semacquire(\u0026m.sema) awoke = true iter = 0 // 清空自旋计数 } } if raceenabled { // race detector 相关 raceAcquire(unsafe.Pointer(m)) } } 在某些临界区，代码执行速度很快，如果通过自旋几次就能获取到锁的所有权，就可以避免加入等待队列， 这样就可以减少上下文的切换，在某些情况下能很好的提高性能。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:3","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"饥饿机制 进过几次优化后，Mutex的性能已经十分好了，但是由于自旋的存在，在特定情况下，有可能出现新人不断 地获取锁，而等待队列中的goroutine一直没有机会获取到锁，Go 团队针对这种情况加入了饥饿机制。 我们拿最新的 Go 1.15 中的源码进行分析 const ( mutexLocked = 1 \u003c\u003c iota // mutex is locked mutexWoken // 唤醒标记 mutexStarving // 饥饿标记 mutexWaiterShift = iota // 偏移量 starvationThresholdNs = 1e6 // 1ms ) 在这个版本中， state的第三位被用作饥饿标记 func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false // 初始饥饿标记 awoke := false iter := 0 old := m.state for { // Don't spin in starvation mode, ownership is handed off to waiters // so we won't be able to acquire the mutex anyway. if old\u0026(mutexLocked|mutexStarving) == mutexLocked \u0026\u0026 runtime_canSpin(iter) { // Active spinning makes sense. // Try to set mutexWoken flag to inform Unlock // to not wake other blocked goroutines. if !awoke \u0026\u0026 old\u0026mutexWoken == 0 \u0026\u0026 old\u003e\u003emutexWaiterShift != 0 \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state continue } new := old // Don't try to acquire starving mutex, new arriving goroutines must queue. if old\u0026mutexStarving == 0 { new |= mutexLocked } if old\u0026(mutexLocked|mutexStarving) != 0 { new += 1 \u003c\u003c mutexWaiterShift } // The current goroutine switches mutex to starvation mode. // But if the mutex is currently unlocked, don't do the switch. // Unlock expects that starving mutex has waiters, which will not // be true in this case. if starving \u0026\u0026 old\u0026mutexLocked != 0 { new |= mutexStarving } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. if new\u0026mutexWoken == 0 { throw(\"sync: inconsistent mutex state\") } new \u0026^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { if old\u0026(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } // If we were already waiting before, queue at the front of the queue. queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } runtime_SemacquireMutex(\u0026m.sema, queueLifo, 1) starving = starving || runtime_nanotime()-waitStartTime \u003e starvationThresholdNs old = m.state if old\u0026mutexStarving != 0 { // If this goroutine was woken and mutex is in starvation mode, // ownership was handed off to us but mutex is in somewhat // inconsistent state: mutexLocked is not set and we are still // accounted as waiter. Fix that. if old\u0026(mutexLocked|mutexWoken) != 0 || old\u003e\u003emutexWaiterShift == 0 { throw(\"sync: inconsistent mutex state\") } delta := int32(mutexLocked - 1\u003c\u003cmutexWaiterShift) if !starving || old\u003e\u003emutexWaiterShift == 1 { // Exit starvation mode. // Critical to do it here and consider wait time. // Starvation mode is so inefficient, that two goroutines // can go lock-step infinitely once they switch mutex // to starvation mode. delta -= mutexStarving } atomic.AddInt32(\u0026m.state, delta) break } awoke = true iter = 0 } else { old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } } (咕了，过几天再写 ","date":"2020-12-14","objectID":"/posts/go_mutex/:4:0","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"一个鸽子 (咕…) ","date":"2020-12-11","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"Hello World 这是一个测试页面 ","date":"2020-12-06","objectID":"/posts/hello_world/:1:0","tags":null,"title":"Hello_world","uri":"/posts/hello_world/"},{"categories":null,"content":"note 从博客园迁移，复习一下以前学的内容 一般的树形DP都是在树上进行，即有N个点和N-1条边。可是有一类问题是N个点和N条边，这样一定会有环，这样的图就叫基环树。 对于这类题，我们可以进行一次dfs，找出环，然后选择环上的任意一条边删除。这样就能变成N个点，N-1条边的树， 可以很容易地使用树形DP解决。 假设将要删去的环上的边为E，边上两端点为u，v。然后分别以u和v为树根做一次DP，去最优值就可以了。 Tips：在存图是，可将cnt的初始值设为1，即第一条边的编号设为2，然后用类似于网络流中存储反向边的方法来做。 模板题： BZOJ 1040[ZJOI2008]骑士 /* Author:Wdvxdr Problem:Bzoj 1040 Time:2017/12/25 */ #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn = 1e6+10; struct node{int v,nxt;}e[maxn\u003c\u003c1]; int head[maxn],cnt=1,a[maxn],n,Rtree,Ltree,DelEdge; bool vis[maxn]; long long f[maxn][2]; inline void add(int u,int v) { e[++cnt] = (node){v,head[u]}; head[u]=cnt; } void dfs(int u,int fa) { vis[u] = 1; for(int i=head[u];i;i=e[i].nxt) { int v = e[i].v; if(v!=fa) if(!vis[v]) { dfs(v,u); } else Rtree = u,Ltree = v,DelEdge=i; } } void dp(int u,int fa) { int v; f[u][0]=0;f[u][1]=a[u]; for(int i=head[u];i;i=e[i].nxt) { if(i==DelEdge||i==(DelEdge^1)) continue; v = e[i].v; if(v!=fa) { dp(v,u); f[u][0] += max(f[v][0],f[v][1]); f[u][1] += f[v][0]; } } } int main() { int t;long long temp,ans=0; scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;i++) { scanf(\"%d%d\",\u0026a[i],\u0026t); add(t,i);add(i,t); } for(int i=1;i\u003c=n;i++) { if(vis[i]) continue; dfs(i,0); dp(Rtree,0); temp = f[Rtree][0]; dp(Ltree,0); temp = max(temp,f[Ltree][0]); ans += temp; } cout \u003c\u003c ans; return 0; } ","date":"2017-12-25","objectID":"/posts/ji-huan-shu-dp/:0:0","tags":null,"title":"基环树DP","uri":"/posts/ji-huan-shu-dp/"},{"categories":null,"content":" Mrs4s 死宅，挖坑不填怪. RainChan 好耶，是GC！ Yukari316 恭喜你发现了一个神必饼干 Richard Chien RCNB!!! bleatingsheep 是个留学萝莉 ","date":"0001-01-01","objectID":"/links/:0:0","tags":null,"title":"友情链接","uri":"/links/"}]