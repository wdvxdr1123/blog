[{"categories":null,"content":"C++11 添加了右值引用的特性，不仅让我们能够使用移动语义，而且 还可以通过完美转发编写接收任意实参的模板 ","date":"2020-12-12","objectID":"/posts/c++_rvalue/:0:0","tags":null,"title":"C++ 与 右值引用","uri":"/posts/c++_rvalue/"},{"categories":null,"content":"左值与右值 在 C++ 中，一切值都分为左值lvalue和右值rvalue 在 C 语言中，我们把等号左边的称为左值，等号右边的称为右值 int a = 0; // 这里0是右值,a是左值 int b = a;// 这里a是右值,b是左值 C++11 中的左值与右值 在 C++11 中，左值和右值的概念被重新解释 L-Value左值中的 L 被重新解释成 Location，即左值代表具有内存地址的一类表达式 R-Value右值中的 R 被重新解释成 Read，即右值代表具有只读的一类表达式 ","date":"2020-12-12","objectID":"/posts/c++_rvalue/:1:0","tags":null,"title":"C++ 与 右值引用","uri":"/posts/c++_rvalue/"},{"categories":null,"content":"右值引用 在C++98中，所有的引用都是左值引用，我们只能对左值取引用 int a = 0; int\u0026 p1 = a; // 合法 int\u0026 p2 = 0; // 非法操作，左值引用无法指向右值 const int\u0026 p3 = 0; // 合法，const引用可以指向右值 在C++11中，提供了右值引用的支持 int a = 0; int\u0026\u0026 p1 = 0; // 合法，右值引用指向右值 int\u0026\u0026 p2 = a; // 非法，右值引用指向左值 标准库中的std::move可以将左值强制转换为右值，例如 int a = 5; int\u0026\u0026 b = std::move(a); // 将左值转换为右值 std::cout \u003c\u003c a; // 输出为 5 std::move这个名字非常右迷惑性，虽然名字是move，但它并没有将一个变量中的值 移入到另一个变量当中，本质上执行的是static_cast\u003cT\u0026\u0026\u003e(lvalue)操作。 ","date":"2020-12-12","objectID":"/posts/c++_rvalue/:2:0","tags":null,"title":"C++ 与 右值引用","uri":"/posts/c++_rvalue/"},{"categories":null,"content":"移动语义 在 C/C++ 中，构造，返回，传参等等默认采用都的是拷贝copy的语义 int a,b; a = 5; b = a; 例如在这份代码中，对b赋值采用的方式是将先拷贝变量a，再将拷贝的临时变量赋值给b， 在变量结构复杂的情况下，复制操作的代价是非常高的，C语言中我们可以使用指针来处理这个问题， 但指针是非常危险的。 于是在 C++ 中，我们C++中可以使用引用，它的机制和指针类似，但是比指针更加安全，引用的 使用让我们可以在传参时使用得安全，快速方式，但并没解决返回和构造的拷贝问题。 在 C++ 11 中右值引用的出现，使得我们可以用移动move语义解决C++中的拷贝问题 (咕咕咕。。。) ","date":"2020-12-12","objectID":"/posts/c++_rvalue/:3:0","tags":null,"title":"C++ 与 右值引用","uri":"/posts/c++_rvalue/"},{"categories":null,"content":"(咕…) ","date":"2020-12-11","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"Hello World 这是一个测试页面 ","date":"2020-12-06","objectID":"/posts/hello_world/:1:0","tags":null,"title":"Hello_world","uri":"/posts/hello_world/"}]