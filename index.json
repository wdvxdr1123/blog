[{"categories":null,"content":"前言 C++是一门古老的编程语言，在算法竞赛中因为其优秀的运行效率和丰富的标准库，成为许多 acmer 和 oier 的 首选语言。在 C++11 面世以后，C++扩充许多特性，给 C++ 这门语言注入了新的活力。 这篇文章将讨论一些能在算法竞赛中提供方便的现代C++的特性 编译环境 大部分oj都已经支持了G++17, 本文所有代码都基于 GCC 9.2 。 ","date":"2021-01-20","objectID":"/posts/morden_c++_in_oj/:1:0","tags":null,"title":"现代C++在算法竞赛中的应用","uri":"/posts/morden_c++_in_oj/"},{"categories":null,"content":"auto auto是c++11引入的新关键字，用于自动推导类型，使用auto可以让我们告别写冗长的类型名 auto a = 1;//推导为int auto t = std::make_tuple(1,1); // 推导为std::tuple\u003cint,int\u003e ","date":"2021-01-20","objectID":"/posts/morden_c++_in_oj/:2:0","tags":null,"title":"现代C++在算法竞赛中的应用","uri":"/posts/morden_c++_in_oj/"},{"categories":null,"content":"区间 for 迭代 在 C++11 引入了基于范围的迭代，让可以使用类似于python中的for x in list :的写法对容器遍历 如果需要读取一个大小为n的数组，在以前我们可能这么做 int n, a[maxn]; std::cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; 使用现代c++可以这么写 int n; cin \u003e\u003e n; vector\u003cint\u003e a(n, 0); for (auto \u0026x : a) cin \u003e\u003e x; ","date":"2021-01-20","objectID":"/posts/morden_c++_in_oj/:3:0","tags":null,"title":"现代C++在算法竞赛中的应用","uri":"/posts/morden_c++_in_oj/"},{"categories":null,"content":"tuple 在传统C++中，我们要打包一组数据通常使用自定义struct，当需要打包的数据为两个时可以使用std::pair。 在现代C++中，你可以使用更方便的std::tuple. 使用std::tuple需要引入头文件 \u003ctuple\u003e，在cppreference中，将std::tuple描述为std::pair的推广, 将pair只能储存两个数值的限制去掉了 在C++17以前可以使用这种方式解包tuple int a, b; auto x = std::make_tuple\u003cint, int\u003e(1, 1); std::tie(a, b) = x; auto c = std::get\u003c0\u003e(x); 在C++17中提供了一种结构化绑定的语法，可以很方便的解包tuple using namespace std; auto x = tuple\u003cint, tuple\u003cint, int\u003e\u003e{1, {2, 3}}; auto \u0026[a, x2] = x; // 还是rust的模式结构nb auto \u0026[b, c] = x2; // a= 1,b= 2,c= 3 cout \u003c\u003c \"a= \" \u003c\u003c a \u003c\u003c \",b= \" \u003c\u003c b \u003c\u003c \",c= \" \u003c\u003c c \u003c\u003c endl; ","date":"2021-01-20","objectID":"/posts/morden_c++_in_oj/:4:0","tags":null,"title":"现代C++在算法竞赛中的应用","uri":"/posts/morden_c++_in_oj/"},{"categories":null,"content":"Golang标准库中提供了互斥锁Mutex的原语来解决并发资源竞争，这篇文章探讨了标准库 中Mutex的实现原理 ","date":"2020-12-14","objectID":"/posts/go_mutex/:0:0","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"基础知识 ","date":"2020-12-14","objectID":"/posts/go_mutex/:1:0","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"信号量 信号量Semaphore 是计算机科学家 Dijkstra 发明的数据结构，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。其本质是一个整数，有两个基本操作： 申请acquire（也称为 wait、decrement 或 P 操作）: 将信号量减 1，如果结果值为负则挂起协程，直到其他线程进行了信号量累加为正数才能恢复。如结果为正数，则继续执行。 释放release（也称 signal、increment 或 V 操作）: 将信号量加 1，如存在被挂起的协程，此时唤醒他们中的一个协程。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:1:1","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"CAS 操作 CAS操作是CPU指令提供的一个原子操作， 其全程为 Compare And Swap，在Go标准库 sync/atomic 中实现了这个方法： // CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value. func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) 这个函数会首先比较指针addr指向的值是否和old是否相等，如果相等则将addr指向的值替换为new，并返回true， 否则不做任何操作，并返回false。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:1:2","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Mutex的第一次提交 在2008年 Russ Cox 提交了第一版的Mutex实现[1]， 当时的实现比较简单，我们先从这一版开始了解Mutex的底层原理，由于当时Go还未发布1.0版本，也没有sync/atomic包，与现在的实现有很大的区别，但这并不影响我们理解其中的逻辑 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:0","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Mutex的定义 export type Mutex struct { key int32; // 记录当前锁是否被某个goroutine持有 sema int32; // 信号量 } 初版的Mutex定义非常简单，使用key记录当前锁是否被持有，sema记录当前信号量 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:1","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"请求锁的实现 func (m *Mutex) Lock() { if xadd(\u0026m.key, 1) == 1 { // 将标记加1，判断是否有其他goroutine持有锁 // changed from 0 to 1; we hold lock return; // 当前 goroutine 持有锁，直接返回 } sys.semacquire(\u0026m.sema); // 挂起当前goroutine，等待调度 } 这个函数实现的很简单，在加锁时，首先将当前锁标记为已持有，如果当前锁没有被其他goroutine持有，则直接返回， 否则，挂起当前goroutine，等待信号量调度。 xadd函数 func xadd(val *int32, delta int32) (new int32) { for { // 不断自旋操作 v := *val; if cas(val, v, v+delta) { // 判断是否被其他goroutine修改 return v+delta; // 返回新值 } } panic(\"unreached\") } xadd通过自旋CAS操作，将val的值加delta，就相当于现在Go语言的atomic.AddInt32 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:2","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"释放锁的实现 释放锁的实现也很简洁: func (m *Mutex) Unlock() { if xadd(\u0026m.key, -1) == 0 { // 将标记减1 // changed from 1 to 0; no contention return; // 如果没有其他goroutine持有锁，直接返回 } sys.semrelease(\u0026m.sema); // 通过信号量唤醒被挂起的goroutine } 释放锁时，首先将当前标记减一，如果当前锁没有被其他goroutine持有，则直接返回， 否则，通过信号量通知运行时，调度被挂起的goroutine。 在这个版本，Mutex已经实现了基本的功能，但是这个版本有一个问题，所有goroutine会排队等待 运行时的调度，虽然这保证了公平性，所有的goroutine都会有机会参与调度，但是从性能的角度上看， 这会导致频繁的上下文切换，如果我们把锁直接交给新人(未挂起的goroutine)，这样就可以避免上下文的切换， 于是Go 团队再 Go1.0 正式版时对Mutex进行了较大的调整。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:3","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"加入唤醒机制 在Go 1.0版本[2]中， Mutex的结构体字段进行了调整 type Mutex struct { state int32 // 复合数据，下文进行解释 sema uint32 // 信号量 } const ( mutexLocked = 1 \u003c\u003c iota // state的第一位，代表当前锁是否被持有 mutexWoken // state的第二位，唤醒标记 mutexWaiterShift = iota // 位移 ) 在这一版中，将Mutex的第一个字段由key改为state，其含义发生了很大的变化，state的第一位表示当前锁是否被持有， 相当于之前的key，state的第二位是唤醒标记，代表当前是否有唤醒的goroutine正在请求锁，剩下的30位用来表示等待中 的Waiter数量。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:0","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Go1.0 请求锁 在这一版中，代码相比第一版有很大变化，其主要优化是给新来的goroutine一些机会，让新goroutine能不参与休眠就获取锁 func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { return // 当前锁未被持有 } awoke := false for { old := m.state new := old | mutexLocked // 新状态加上锁 if old\u0026mutexLocked != 0 { new = old + 1\u003c\u003cmutexWaiterShift // 如果已经有goroutine持有锁，则等待的 Waiter + 1 } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. new \u0026^= mutexWoken // 清空唤醒标记 } if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { // 置新状态 if old\u0026mutexLocked == 0 { break // 旧状态锁已释放，获取当前锁 } runtime_Semacquire(\u0026m.sema) // 请求信号量 awoke = true } } } 我们可以用下面这个状态图表示请求锁的过程 我们可以发现，在这版的Mutex中，给新来的goroutine会在加入等待队列前就去尝试获取锁， 如果失败则加入等待队列中 ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:1","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Go1.0 释放锁 同时在Go 1.0中，释放锁的代码也变得更加复杂了 func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026m.state, -mutexLocked) // 去掉持有锁标记 if (new+mutexLocked)\u0026mutexLocked == 0 { panic(\"sync: unlock of unlocked mutex\") // 重复Unlock时panic } old := new for { // 如果没有其他的waiter // 或者已经有唤醒的goroutine if old\u003e\u003emutexWaiterShift == 0 || old\u0026(mutexLocked|mutexWoken) != 0 { return } // 挑选一个waiter唤醒 new = (old - 1\u003c\u003cmutexWaiterShift) | mutexWoken // 打上唤醒标记 if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { // 置新状态 runtime_Semrelease(\u0026m.sema) return } old = m.state } } 在释放锁时，首先会将锁标记为未锁状态，如果当前锁已经是未锁状态，则会panic(第5行) 如果当前已经有唤醒的goroutine或者没有等待中的waiter，我们就什么都不用做，其他goroutine会自己抢夺这把锁 如果没有唤醒的goroutine,就从等待队列中唤醒一个goroutine ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:2","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"给新 Goroutine 更多机会 在 Go1.5 版本中，Go团队又对Mutex进行了一次优化[3] 在某些临界区，代码执行的速度很快，如果加入等待队列就会浪费很多时间，Go 团队针对这一情景对Mutex进行了优化 func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { if raceenabled { // race detector 相关 raceAcquire(unsafe.Pointer(m)) } return } awoke := false iter := 0 // 自旋次数 for { old := m.state new := old | mutexLocked if old\u0026mutexLocked != 0 { // 当前锁被持有 if runtime_canSpin(iter) { // 检测是否可以自旋 // 如果当前的没有其他唤醒的goroutine // 尝试将当前goroutine置为唤醒状态 // 提醒 Unlock 不去唤醒其他goroutine if !awoke \u0026\u0026 old\u0026mutexWoken == 0 \u0026\u0026 old\u003e\u003emutexWaiterShift != 0 \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) { awoke = true // 设置当前唤醒状态 } runtime_doSpin() iter++ continue // 自旋再次请求锁 } new = old + 1\u003c\u003cmutexWaiterShift // 加入等待队列 } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. if new\u0026mutexWoken == 0 { panic(\"sync: inconsistent mutex state\") } new \u0026^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { if old\u0026mutexLocked == 0 { break } runtime_Semacquire(\u0026m.sema) awoke = true iter = 0 // 清空自旋计数 } } if raceenabled { // race detector 相关 raceAcquire(unsafe.Pointer(m)) } } 在某些临界区，代码执行速度很快，如果通过自旋几次就能获取到锁的所有权，就可以避免加入等待队列， 这样就可以减少上下文的切换，在某些情况下能很好的提高性能。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:3","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"饥饿机制 进过几次优化后，Mutex的性能已经十分好了，但是由于自旋的存在，在特定情况下，有可能出现新人不断 地获取锁，而等待队列中的goroutine一直没有机会获取到锁，Go 团队针对这种情况加入了饥饿机制。 我们拿最新的 Go 1.15 中的源码进行分析 const ( mutexLocked = 1 \u003c\u003c iota // mutex is locked mutexWoken // 唤醒标记 mutexStarving // 饥饿标记 mutexWaiterShift = iota // 偏移量 starvationThresholdNs = 1e6 // 1ms ) 在这个版本中， state的第三位被用作饥饿标记 func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false // 初始饥饿标记 awoke := false iter := 0 old := m.state for { // Don't spin in starvation mode, ownership is handed off to waiters // so we won't be able to acquire the mutex anyway. if old\u0026(mutexLocked|mutexStarving) == mutexLocked \u0026\u0026 runtime_canSpin(iter) { // Active spinning makes sense. // Try to set mutexWoken flag to inform Unlock // to not wake other blocked goroutines. if !awoke \u0026\u0026 old\u0026mutexWoken == 0 \u0026\u0026 old\u003e\u003emutexWaiterShift != 0 \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state continue } new := old // Don't try to acquire starving mutex, new arriving goroutines must queue. if old\u0026mutexStarving == 0 { new |= mutexLocked } if old\u0026(mutexLocked|mutexStarving) != 0 { new += 1 \u003c\u003c mutexWaiterShift } // The current goroutine switches mutex to starvation mode. // But if the mutex is currently unlocked, don't do the switch. // Unlock expects that starving mutex has waiters, which will not // be true in this case. if starving \u0026\u0026 old\u0026mutexLocked != 0 { new |= mutexStarving } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. if new\u0026mutexWoken == 0 { throw(\"sync: inconsistent mutex state\") } new \u0026^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { if old\u0026(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } // If we were already waiting before, queue at the front of the queue. queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } runtime_SemacquireMutex(\u0026m.sema, queueLifo, 1) starving = starving || runtime_nanotime()-waitStartTime \u003e starvationThresholdNs old = m.state if old\u0026mutexStarving != 0 { // If this goroutine was woken and mutex is in starvation mode, // ownership was handed off to us but mutex is in somewhat // inconsistent state: mutexLocked is not set and we are still // accounted as waiter. Fix that. if old\u0026(mutexLocked|mutexWoken) != 0 || old\u003e\u003emutexWaiterShift == 0 { throw(\"sync: inconsistent mutex state\") } delta := int32(mutexLocked - 1\u003c\u003cmutexWaiterShift) if !starving || old\u003e\u003emutexWaiterShift == 1 { // Exit starvation mode. // Critical to do it here and consider wait time. // Starvation mode is so inefficient, that two goroutines // can go lock-step infinitely once they switch mutex // to starvation mode. delta -= mutexStarving } atomic.AddInt32(\u0026m.state, delta) break } awoke = true iter = 0 } else { old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } } (咕了，过几天再写 ","date":"2020-12-14","objectID":"/posts/go_mutex/:4:0","tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"C++11 添加了右值引用的特性，不仅让我们能够使用移动语义，而且 还可以通过完美转发编写接收任意实参的模板 ","date":"2020-12-12","objectID":"/posts/c++_rvalue/:0:0","tags":null,"title":"C++ 与 右值引用","uri":"/posts/c++_rvalue/"},{"categories":null,"content":"左值与右值 在 C++ 中，一切值都分为左值lvalue和右值rvalue 在 C 语言中，我们把等号左边的称为左值，等号右边的称为右值 int a = 0; // 这里0是右值,a是左值 int b = a;// 这里a是右值,b是左值 C++11 中的左值与右值 在 C++11 中，左值和右值的概念被重新解释 L-Value左值中的 L 被重新解释成 Location，即左值代表具有内存地址的一类表达式 R-Value右值中的 R 被重新解释成 Read，即右值代表具有只读的一类表达式 ","date":"2020-12-12","objectID":"/posts/c++_rvalue/:1:0","tags":null,"title":"C++ 与 右值引用","uri":"/posts/c++_rvalue/"},{"categories":null,"content":"右值引用 在C++98中，所有的引用都是左值引用，我们只能对左值取引用 int a = 0; int\u0026 p1 = a; // 合法 int\u0026 p2 = 0; // 非法操作，左值引用无法指向右值 const int\u0026 p3 = 0; // 合法，const引用可以指向右值 在C++11中，提供了右值引用的支持 int a = 0; int\u0026\u0026 p1 = 0; // 合法，右值引用指向右值 int\u0026\u0026 p2 = a; // 非法，右值引用指向左值 标准库中的std::move可以将左值强制转换为右值，例如 int a = 5; int\u0026\u0026 b = std::move(a); // 将左值转换为右值 std::cout \u003c\u003c a; // 输出为 5 std::move这个名字非常右迷惑性，虽然名字是move，但它并没有将一个变量中的值 移入到另一个变量当中，本质上执行的是static_cast\u003cT\u0026\u0026\u003e(lvalue)操作。 ","date":"2020-12-12","objectID":"/posts/c++_rvalue/:2:0","tags":null,"title":"C++ 与 右值引用","uri":"/posts/c++_rvalue/"},{"categories":null,"content":"移动语义 在 C/C++ 中，构造，返回，传参等等默认采用都的是拷贝copy的语义 int a,b; a = 5; b = a; 例如在这份代码中，对b赋值采用的方式是将先拷贝变量a，再将拷贝的临时变量赋值给b， 在变量结构复杂的情况下，复制操作的代价是非常高的，C语言中我们可以使用指针来处理这个问题， 但指针是非常危险的。 于是在 C++ 中，我们C++中可以使用引用，它的机制和指针类似，但是比指针更加安全，引用的 使用让我们可以在传参时使用得安全，快速方式，但并没解决返回和构造的拷贝问题。 在 C++ 11 中右值引用的出现，使得我们可以用移动move语义解决C++中的拷贝问题 (咕咕咕。。。) ","date":"2020-12-12","objectID":"/posts/c++_rvalue/:3:0","tags":null,"title":"C++ 与 右值引用","uri":"/posts/c++_rvalue/"},{"categories":null,"content":"(咕…) ","date":"2020-12-11","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"Hello World 这是一个测试页面 ","date":"2020-12-06","objectID":"/posts/hello_world/:1:0","tags":null,"title":"Hello_world","uri":"/posts/hello_world/"}]