[{"categories":null,"content":"调用非导出函数 在 go 语言中，所有的导出与非导出都由标志符的第一个字母是否大写决定。 有时候，我们可能需要调用一个私有方法或私有函数。对于函数，我们可以使用 linkname 解决这个问题。 例如 package a func test() { println(\"hello world from myproject/a\") } type A struct {} func (*A) test1() { println(\"test1\") } func (A) test2() { println(\"test2\") } 如果我们需要调用 a 包中的 test 函数，使用 linkname 可以很轻松的做到。 package main import ( _ \"unsafe\" // linkname require unsafe \"myproject/a\" ) func main() { test() } //go:linkname test myproject/a.test func test() ","date":"2021-08-11","objectID":"/posts/8.11.invoke_non_export_method_in_go/:1:0","series":null,"tags":null,"title":"突破限制，在 Go 中调用非导出方法","uri":"/posts/8.11.invoke_non_export_method_in_go/"},{"categories":null,"content":"调用非导出方法 但是如果我们需要调用类型A的两个私有方法， linkname似乎就不太好用了。 ","date":"2021-08-11","objectID":"/posts/8.11.invoke_non_export_method_in_go/:2:0","series":null,"tags":null,"title":"突破限制，在 Go 中调用非导出方法","uri":"/posts/8.11.invoke_non_export_method_in_go/"},{"categories":null,"content":"反射? package main import ( \"reflect\" \"myproject/a\" ) func main() { var v a.A rv := reflect.ValueOf(v) rv.MethodByName(\"test1\").Call([]reflect.Value{}) } 这似乎是一条可行的路， 但是 reflect 包会强制检查函数的导出性， 调用非导出函数是被禁止的。 ","date":"2021-08-11","objectID":"/posts/8.11.invoke_non_export_method_in_go/:2:1","series":null,"tags":null,"title":"突破限制，在 Go 中调用非导出方法","uri":"/posts/8.11.invoke_non_export_method_in_go/"},{"categories":null,"content":"将方法回归函数 对于 go 来说，所有的方法都会被编译成一个包含接收器的函数。同时 go 也提供了另外一种方法调用方法。 例如: file, err := os.Open(\"some file\") if err != nil { panic(err) } buf := make([]byte, 1024) file.Read(buf) 可以等价的编写为 file, err := os.Open(\"some file\") if err != nil { panic(err) } buf := make([]byte, 1024) (*os.File).Read(file, buf) 所以我们调用非导出函数的思路也复现出来了: go 编译器会将方法 func (receiver *Type) SomeFunc(args...) 编译成函数 func SomeFunc(receiver *Type,args ...) 利用这个特性，我们可以将方法转换成函数，这样我们就可以使用调用非导出函数的方法，处理非导出方法了。 package main import ( _ \"unsafe\" // linkname require unsafe \"myproject/a\" ) func main() { var v a.A test1(\u0026a) test2(a) } // 指针接收器 //go:linkname test myproject/a.(*A).test1 func test1(_ *a.A) // 非指针接收器 //go:linkname test myproject/a.A.test2 func test2(_ a.A) ","date":"2021-08-11","objectID":"/posts/8.11.invoke_non_export_method_in_go/:2:2","series":null,"tags":null,"title":"突破限制，在 Go 中调用非导出方法","uri":"/posts/8.11.invoke_non_export_method_in_go/"},{"categories":null,"content":"缘起 在群里聊天时，听到了群友说在更新了Go 1.16后，使用c-shared编译无法导出C文件中 定义的导出函数。处于兴趣，我便开始探索无法导出的缘由。 ","date":"2021-04-02","objectID":"/posts/go1.16-cgo-export/:1:0","series":null,"tags":null,"title":"在Go1.16导出C文件中的函数","uri":"/posts/go1.16-cgo-export/"},{"categories":null,"content":"排查过程 package main import \"C\" //export AddGo func AddGo(a C.int,b C.int) C.int { return C.int(int(a) + int(b)) } func main() {} extern int __stdcall AddC(int a,int b) { return a + b; } 将这两文件放一个文件夹，使用 go build -buildmode=c-shared -o a.dll 进行编译， 然后使用dumpbin工具查看导出函数 Go 1.16 ordinal hint RVA name 1 0 0006F640 AddGo 2 1 00138410 _cgo_dummy_export 发现确实只导出了Go文件中使用 //export 导出的函数。 ","date":"2021-04-02","objectID":"/posts/go1.16-cgo-export/:2:0","series":null,"tags":null,"title":"在Go1.16导出C文件中的函数","uri":"/posts/go1.16-cgo-export/"},{"categories":null,"content":"Go 1.16 在CGO中的改动 在go仓库中搜寻有无类似 issue 时，go1.16 修复的一个 bug 引起了我的注意 #43591 其大致内容是，使用 c-shared 编译时，会导出很多很多函数，不仅仅是标注为 //export 的函数，很多标准库中的函数，包括运行时内部的 函数也被导出。 我查看了修复这个 bug 的 commit 记录link. 修复的 commit 记录 从这条 commit 中可以看出， cgo 工具在go 1.16中为所有Go文件中定义的导出函数加上了 __declspec(dllexport)， 这样没有使用 //export 的函数就不会被导出，但是我们的 C 文件中定义的函数也会被忽略。 由此，我们很容易得出解决方法——将c函数加上__declspec(dllexport)。 extern int __stdcall __declspec(dllexport) AddC(int a,int b) { return a + b; } 重新编译后，使用 dumpbin 查看导出函数 ordinal hint RVA name 1 0 0006F6A0 AddC 2 1 0006F640 AddGo 3 2 00138410 _cgo_dummy_export 不出所料，AddC 函数成功的被导出。问题成功解决!!! ","date":"2021-04-02","objectID":"/posts/go1.16-cgo-export/:3:0","series":null,"tags":null,"title":"在Go1.16导出C文件中的函数","uri":"/posts/go1.16-cgo-export/"},{"categories":null,"content":"Golang标准库中提供了互斥锁Mutex的原语来解决并发资源竞争，这篇文章探讨了标准库 中Mutex的实现原理 ","date":"2020-12-14","objectID":"/posts/go_mutex/:0:0","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"基础知识 ","date":"2020-12-14","objectID":"/posts/go_mutex/:1:0","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"信号量 信号量Semaphore 是计算机科学家 Dijkstra 发明的数据结构，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。其本质是一个整数，有两个基本操作： 申请acquire（也称为 wait、decrement 或 P 操作）: 将信号量减 1，如果结果值为负则挂起协程，直到其他线程进行了信号量累加为正数才能恢复。如结果为正数，则继续执行。 释放release（也称 signal、increment 或 V 操作）: 将信号量加 1，如存在被挂起的协程，此时唤醒他们中的一个协程。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:1:1","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"CAS 操作 CAS操作是CPU指令提供的一个原子操作， 其全程为 Compare And Swap，在Go标准库 sync/atomic 中实现了这个方法： // CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value. func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) 这个函数会首先比较指针addr指向的值是否和old是否相等，如果相等则将addr指向的值替换为new，并返回true， 否则不做任何操作，并返回false。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:1:2","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Mutex的第一次提交 在2008年 Russ Cox 提交了第一版的Mutex实现[1]， 当时的实现比较简单，我们先从这一版开始了解Mutex的底层原理，由于当时Go还未发布1.0版本，也没有sync/atomic包，与现在的实现有很大的区别，但这并不影响我们理解其中的逻辑 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:0","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Mutex的定义 export type Mutex struct { key int32; // 记录当前锁是否被某个goroutine持有 sema int32; // 信号量 } 初版的Mutex定义非常简单，使用key记录当前锁是否被持有，sema记录当前信号量 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:1","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"请求锁的实现 func (m *Mutex) Lock() { if xadd(\u0026m.key, 1) == 1 { // 将标记加1，判断是否有其他goroutine持有锁 // changed from 0 to 1; we hold lock return; // 当前 goroutine 持有锁，直接返回 } sys.semacquire(\u0026m.sema); // 挂起当前goroutine，等待调度 } 这个函数实现的很简单，在加锁时，首先将当前锁标记为已持有，如果当前锁没有被其他goroutine持有，则直接返回， 否则，挂起当前goroutine，等待信号量调度。 xadd函数 func xadd(val *int32, delta int32) (new int32) { for { // 不断自旋操作 v := *val; if cas(val, v, v+delta) { // 判断是否被其他goroutine修改 return v+delta; // 返回新值 } } panic(\"unreached\") } xadd通过自旋CAS操作，将val的值加delta，就相当于现在Go语言的atomic.AddInt32 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:2","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"释放锁的实现 释放锁的实现也很简洁: func (m *Mutex) Unlock() { if xadd(\u0026m.key, -1) == 0 { // 将标记减1 // changed from 1 to 0; no contention return; // 如果没有其他goroutine持有锁，直接返回 } sys.semrelease(\u0026m.sema); // 通过信号量唤醒被挂起的goroutine } 释放锁时，首先将当前标记减一，如果当前锁没有被其他goroutine持有，则直接返回， 否则，通过信号量通知运行时，调度被挂起的goroutine。 在这个版本，Mutex已经实现了基本的功能，但是这个版本有一个问题，所有goroutine会排队等待 运行时的调度，虽然这保证了公平性，所有的goroutine都会有机会参与调度，但是从性能的角度上看， 这会导致频繁的上下文切换，如果我们把锁直接交给新人(未挂起的goroutine)，这样就可以避免上下文的切换， 于是Go 团队再 Go1.0 正式版时对Mutex进行了较大的调整。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:2:3","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"加入唤醒机制 在Go 1.0版本[2]中， Mutex的结构体字段进行了调整 type Mutex struct { state int32 // 复合数据，下文进行解释 sema uint32 // 信号量 } const ( mutexLocked = 1 \u003c\u003c iota // state的第一位，代表当前锁是否被持有 mutexWoken // state的第二位，唤醒标记 mutexWaiterShift = iota // 位移 ) 在这一版中，将Mutex的第一个字段由key改为state，其含义发生了很大的变化，state的第一位表示当前锁是否被持有， 相当于之前的key，state的第二位是唤醒标记，代表当前是否有唤醒的goroutine正在请求锁，剩下的30位用来表示等待中 的Waiter数量。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:0","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Go1.0 请求锁 在这一版中，代码相比第一版有很大变化，其主要优化是给新来的goroutine一些机会，让新goroutine能不参与休眠就获取锁 func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { return // 当前锁未被持有 } awoke := false for { old := m.state new := old | mutexLocked // 新状态加上锁 if old\u0026mutexLocked != 0 { new = old + 1\u003c\u003cmutexWaiterShift // 如果已经有goroutine持有锁，则等待的 Waiter + 1 } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. new \u0026^= mutexWoken // 清空唤醒标记 } if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { // 置新状态 if old\u0026mutexLocked == 0 { break // 旧状态锁已释放，获取当前锁 } runtime_Semacquire(\u0026m.sema) // 请求信号量 awoke = true } } } 我们可以用下面这个状态图表示请求锁的过程 我们可以发现，在这版的Mutex中，给新来的goroutine会在加入等待队列前就去尝试获取锁， 如果失败则加入等待队列中 ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:1","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"Go1.0 释放锁 同时在Go 1.0中，释放锁的代码也变得更加复杂了 func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026m.state, -mutexLocked) // 去掉持有锁标记 if (new+mutexLocked)\u0026mutexLocked == 0 { panic(\"sync: unlock of unlocked mutex\") // 重复Unlock时panic } old := new for { // 如果没有其他的waiter // 或者已经有唤醒的goroutine if old\u003e\u003emutexWaiterShift == 0 || old\u0026(mutexLocked|mutexWoken) != 0 { return } // 挑选一个waiter唤醒 new = (old - 1\u003c\u003cmutexWaiterShift) | mutexWoken // 打上唤醒标记 if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { // 置新状态 runtime_Semrelease(\u0026m.sema) return } old = m.state } } 在释放锁时，首先会将锁标记为未锁状态，如果当前锁已经是未锁状态，则会panic(第5行) 如果当前已经有唤醒的goroutine或者没有等待中的waiter，我们就什么都不用做，其他goroutine会自己抢夺这把锁 如果没有唤醒的goroutine,就从等待队列中唤醒一个goroutine ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:2","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"给新 Goroutine 更多机会 在 Go1.5 版本中，Go团队又对Mutex进行了一次优化[3] 在某些临界区，代码执行的速度很快，如果加入等待队列就会浪费很多时间，Go 团队针对这一情景对Mutex进行了优化 func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { if raceenabled { // race detector 相关 raceAcquire(unsafe.Pointer(m)) } return } awoke := false iter := 0 // 自旋次数 for { old := m.state new := old | mutexLocked if old\u0026mutexLocked != 0 { // 当前锁被持有 if runtime_canSpin(iter) { // 检测是否可以自旋 // 如果当前的没有其他唤醒的goroutine // 尝试将当前goroutine置为唤醒状态 // 提醒 Unlock 不去唤醒其他goroutine if !awoke \u0026\u0026 old\u0026mutexWoken == 0 \u0026\u0026 old\u003e\u003emutexWaiterShift != 0 \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) { awoke = true // 设置当前唤醒状态 } runtime_doSpin() iter++ continue // 自旋再次请求锁 } new = old + 1\u003c\u003cmutexWaiterShift // 加入等待队列 } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. if new\u0026mutexWoken == 0 { panic(\"sync: inconsistent mutex state\") } new \u0026^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { if old\u0026mutexLocked == 0 { break } runtime_Semacquire(\u0026m.sema) awoke = true iter = 0 // 清空自旋计数 } } if raceenabled { // race detector 相关 raceAcquire(unsafe.Pointer(m)) } } 在某些临界区，代码执行速度很快，如果通过自旋几次就能获取到锁的所有权，就可以避免加入等待队列， 这样就可以减少上下文的切换，在某些情况下能很好的提高性能。 ","date":"2020-12-14","objectID":"/posts/go_mutex/:3:3","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"饥饿机制 进过几次优化后，Mutex的性能已经十分好了，但是由于自旋的存在，在特定情况下，有可能出现新人不断 地获取锁，而等待队列中的goroutine一直没有机会获取到锁，Go 团队针对这种情况加入了饥饿机制。 我们拿最新的 Go 1.15 中的源码进行分析 const ( mutexLocked = 1 \u003c\u003c iota // mutex is locked mutexWoken // 唤醒标记 mutexStarving // 饥饿标记 mutexWaiterShift = iota // 偏移量 starvationThresholdNs = 1e6 // 1ms ) 在这个版本中， state的第三位被用作饥饿标记 func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false // 初始饥饿标记 awoke := false iter := 0 old := m.state for { // Don't spin in starvation mode, ownership is handed off to waiters // so we won't be able to acquire the mutex anyway. if old\u0026(mutexLocked|mutexStarving) == mutexLocked \u0026\u0026 runtime_canSpin(iter) { // Active spinning makes sense. // Try to set mutexWoken flag to inform Unlock // to not wake other blocked goroutines. if !awoke \u0026\u0026 old\u0026mutexWoken == 0 \u0026\u0026 old\u003e\u003emutexWaiterShift != 0 \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state continue } new := old // Don't try to acquire starving mutex, new arriving goroutines must queue. if old\u0026mutexStarving == 0 { new |= mutexLocked } if old\u0026(mutexLocked|mutexStarving) != 0 { new += 1 \u003c\u003c mutexWaiterShift } // The current goroutine switches mutex to starvation mode. // But if the mutex is currently unlocked, don't do the switch. // Unlock expects that starving mutex has waiters, which will not // be true in this case. if starving \u0026\u0026 old\u0026mutexLocked != 0 { new |= mutexStarving } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. if new\u0026mutexWoken == 0 { throw(\"sync: inconsistent mutex state\") } new \u0026^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { if old\u0026(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } // If we were already waiting before, queue at the front of the queue. queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } runtime_SemacquireMutex(\u0026m.sema, queueLifo, 1) starving = starving || runtime_nanotime()-waitStartTime \u003e starvationThresholdNs old = m.state if old\u0026mutexStarving != 0 { // If this goroutine was woken and mutex is in starvation mode, // ownership was handed off to us but mutex is in somewhat // inconsistent state: mutexLocked is not set and we are still // accounted as waiter. Fix that. if old\u0026(mutexLocked|mutexWoken) != 0 || old\u003e\u003emutexWaiterShift == 0 { throw(\"sync: inconsistent mutex state\") } delta := int32(mutexLocked - 1\u003c\u003cmutexWaiterShift) if !starving || old\u003e\u003emutexWaiterShift == 1 { // Exit starvation mode. // Critical to do it here and consider wait time. // Starvation mode is so inefficient, that two goroutines // can go lock-step infinitely once they switch mutex // to starvation mode. delta -= mutexStarving } atomic.AddInt32(\u0026m.state, delta) break } awoke = true iter = 0 } else { old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } } (咕了，过几天再写 ","date":"2020-12-14","objectID":"/posts/go_mutex/:4:0","series":null,"tags":null,"title":"Golang Mutex源码分析","uri":"/posts/go_mutex/"},{"categories":null,"content":"一个鸽子(咕…) ","date":"2020-12-11","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于ID 滚键盘出来的，硬凑个理由就是: 在键盘上排列为一个X ","date":"2020-12-11","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" note 从博客园迁移，复习一下以前学的内容 一般的树形DP都是在树上进行，即有N个点和N-1条边。可是有一类问题是N个点和N条边，这样一定会有环，这样的图就叫基环树。 对于这类题，我们可以进行一次dfs，找出环，然后选择环上的任意一条边删除。这样就能变成N个点，N-1条边的树， 可以很容易地使用树形DP解决。 假设将要删去的环上的边为E，边上两端点为u，v。然后分别以u和v为树根做一次DP，去最优值就可以了。 Tips：在存图是，可将cnt的初始值设为1，即第一条边的编号设为2，然后用类似于网络流中存储反向边的方法来做。 模板题： BZOJ 1040[ZJOI2008]骑士 /* Author:Wdvxdr Problem:Bzoj 1040 Time:2017/12/25 */ #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 1e6+10; struct node{int v,nxt;}e[maxn\u003c\u003c1]; int head[maxn],cnt=1,a[maxn],n,Rtree,Ltree,DelEdge; bool vis[maxn]; long long f[maxn][2]; inline void add(int u,int v) { e[++cnt] = (node){v,head[u]}; head[u]=cnt; } void dfs(int u,int fa) { vis[u] = 1; for(int i=head[u];i;i=e[i].nxt) { int v = e[i].v; if(v!=fa) if(!vis[v]) { dfs(v,u); } else Rtree = u,Ltree = v,DelEdge=i; } } void dp(int u,int fa) { int v; f[u][0]=0;f[u][1]=a[u]; for(int i=head[u];i;i=e[i].nxt) { if(i==DelEdge||i==(DelEdge^1)) continue; v = e[i].v; if(v!=fa) { dp(v,u); f[u][0] += max(f[v][0],f[v][1]); f[u][1] += f[v][0]; } } } int main() { int t;long long temp,ans=0; scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;i++) { scanf(\"%d%d\",\u0026a[i],\u0026t); add(t,i);add(i,t); } for(int i=1;i\u003c=n;i++) { if(vis[i]) continue; dfs(i,0); dp(Rtree,0); temp = f[Rtree][0]; dp(Ltree,0); temp = max(temp,f[Ltree][0]); ans += temp; } cout \u003c\u003c ans; return 0; } ","date":"2017-12-25","objectID":"/posts/ji-huan-shu-dp/:0:0","series":null,"tags":null,"title":"基环树DP","uri":"/posts/ji-huan-shu-dp/"},{"categories":null,"content":" Mrs4s 死宅，挖坑不填怪. Richard Chien RCNB!!! 鈴木観理 理酱! RainChan 好耶，是GC！ Yukari316 恭喜你发现了一个神必饼干 bleatingsheep 是个留学萝莉 yyuueexxiinngg 西城佬！！！ 秋葉 一个神秘的人 Kyomotoi 一个菜鸡的自我修养 ishkong 好耶，是时空佬 maxesisn 一个神秘的人 Gaein nidb 一个神秘的人 synodriver 一个神秘的人 地河 是魔法地河! TheSnowfield Atmosphere ","date":"0001-01-01","objectID":"/links/:0:0","series":null,"tags":null,"title":"友情链接","uri":"/links/"}]